apiVersion: scaffolder.backstage.io/v1beta3
# https://backstage.io/docs/features/software-catalog/descriptor-format#kind-template
kind: Template
metadata:
  name: llama-stack-agentic
  title: Llama Stack Agentic AI Workflow
  description: |
    Deploy a sophisticated AI Agentic Workflow application that provides an intelligent 
    chat interface with dynamic, stateful workflow orchestration using LangGraph and 
    Llama Stack. Features multi-agent routing, RAG-powered responses, Kubernetes 
    integration via MCP, and content safety guardrails.
  tags: ["ai", "llama-stack", "langgraph", "mcp", "rag", "agents", "kubernetes", "streamlit"]
  annotations:
    backstage.io/techdocs-ref: dir:.
spec:
  type: service
  owner: rhdh-pai
  parameters:
    # ==================== Application Information ====================
    - title: Application Information
      required:
        - name
        - owner
        - argoNS
        - argoInstance
        - argoProject
      ui:order:
        - name
        - owner
        - argoNS
        - argoInstance
        - argoProject
        - includeArgoLabel
        - argoAppLabel
        - '*'
      properties:
        name:
          title: Name
          type: string
          description: Unique name of the component
          ui:autofocus: true
          ui:field: EntityNamePicker
          maxLength: 63
        owner:
          title: Owner
          type: string
          description: Owner of the component
          default: user:guest
          ui:field: OwnerPicker
          ui:options: {}
        argoNS:
          title: ArgoCD Namespace
          type: string
          description: The target namespace of the ArgoCD deployment
          default: openshift-gitops
          maxLength: 63
        argoInstance:
          title: ArgoCD Instance
          type: string
          description: The target ArgoCD instance name
          default: default
          maxLength: 63
        argoProject:
          title: ArgoCD Project
          type: string
          description: The target ArgoCD project name
          default: default
          maxLength: 63
        includeArgoLabel:
          title: Include ArgoCD App Label?
          type: boolean
          description: Include a user provided ArgoCD Application Label
          default: true
      dependencies:
        includeArgoLabel:
          oneOf:
            - required:
                - argoAppLabel
              properties:
                includeArgoLabel:
                  const: true
                argoAppLabel:
                  title: ArgoCD Application Label
                  type: string
                  description: Label RHDH uses to identify ArgoCD Applications
                  default: rolling-demo

    # ==================== Llama Stack Configuration ====================
    - title: Llama Stack Configuration
      description: |
        Configure the Llama Stack AI inference server. You must create a Kubernetes Secret 
        containing the required API keys before or after deploying this template.
        See the TechDocs for a secrets example template.
      required:
        - vllmUrl
        - llamaStackSecretName
      ui:order:
        - vllmUrl
        - safetyModel
        - llamaStackSecretName
        - '*'
      properties:
        vllmUrl:
          title: vLLM Server URL
          type: string
          description: URL of the vLLM inference server endpoint
          ui:help: "Example: https://your-vllm-server.apps.cluster.example.com/v1"
        safetyModel:
          title: Safety Model (SAFETY_MODEL)
          type: string
          default: ollama/llama-guard3:8b
          description: Model for content safety guardrails
          ui:help: "Optional - Default: ollama/llama-guard3:8b"
        llamaStackSecretName:
          title: Llama Stack Secrets Name
          type: string
          default: llama-stack-secrets
          description: |
            Name of a Kubernetes Secret you will create containing:
            • VLLM_API_KEY - API key for vLLM server
            • OPENAI_API_KEY - Your OpenAI API key (for embeddings)
            See TechDocs "Secrets Configuration" for example YAML.
          ui:help: |
            kubectl create secret generic <secret-name> \
              --from-literal=VLLM_API_KEY=<your-vllm-key> \
              --from-literal=OPENAI_API_KEY=<your-openai-key>

    # ==================== Application Configuration ====================
    - title: Application Configuration
      description: |
        Configure the Streamlit AI application. You must create a Kubernetes Secret 
        containing the GitHub token before or after deploying this template.
        See the TechDocs for a secrets example template.
      required:
        - inferenceModel
        - mcpToolModel
        - githubRepoUrl
        - appSecretName
      ui:order:
        - inferenceModel
        - mcpToolModel
        - githubRepoUrl
        - appSecretName
        - '*'
      properties:
        inferenceModel:
          title: Inference Model (INFERENCE_MODEL)
          type: string
          default: vllm/redhataiqwen3-8b-fp8-dynamic
          description: Model ID for classification and inference
          ui:help: "Default: vllm/redhataiqwen3-8b-fp8-dynamic"
        mcpToolModel:
          title: MCP Tool Model (MCP_TOOL_MODEL)
          type: string
          default: vllm/redhataiqwen3-8b-fp8-dynamic
          description: Model for MCP Kubernetes tool calls (must support function calling)
          ui:help: "Default: vllm/redhataiqwen3-8b-fp8-dynamic"
        githubRepoUrl:
          title: GitHub Repository URL (GITHUB_URL)
          type: string
          description: GitHub repository URL for issue creation and comments
          ui:help: "Example: https://github.com/your-org/your-repo"
        appSecretName:
          title: Application Secrets Name
          type: string
          default: app-secrets
          description: |
            Name of a Kubernetes Secret you will create containing:
            • GITHUB_TOKEN - GitHub Personal Access Token with 'repo' scope for creating issues and comments
            See TechDocs "Secrets Configuration" for example YAML.
          ui:help: |
            Create a GitHub Personal Access Token at: https://github.com/settings/tokens
            Required scopes: repo (for issue creation and comments)
            See: https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens
            
            kubectl create secret generic <secret-name> --from-literal=GITHUB_TOKEN=<your-github-pat>

    # ==================== Repository Information ====================
    - title: Application Repository Information
      required:
        - hostType
        - repoOwner
        - repoName
        - branch
      properties:
        hostType:
          title: Host Type
          type: string
          enum:
            - GitHub
            - GitLab
          default: GitHub
        repoOwner:
          title: Repository Owner
          type: string
          ui:help: The organization, user or project that this repo will belong to
        repoName:
          title: Repository Name
          type: string
        branch:
          title: Repository Default Branch
          type: string
          default: main
      dependencies:
        hostType:
          oneOf:
            - required:
                - githubServer
              properties:
                hostType:
                  const: GitHub
                githubServer:
                  title: Repository Server
                  type: string
                  default: github.com
                  ui:help: "On-prem example: github.apps.cluster.example.com"
            - required:
                - gitlabServer
              properties:
                hostType:
                  const: GitLab
                gitlabServer:
                  title: Repository Server
                  type: string
                  default: gitlab.com
                  ui:help: "On-prem example: gitlab.apps.cluster.example.com"

    # ==================== Deployment Information ====================
    - title: Deployment Information
      required:
        - imageRegistry
        - imageOrg
        - imageName
        - namespace
        - pipelineSecretName
      ui:order:
        - imageRegistry
        - imageOrg
        - imageName
        - namespace
        - pipelineSecretName
        - deployArgoCDApplicationOnRemoteCluster
        - remoteClusterAPIUrl
        - remoteClusterDeploymentNamespace
      properties:
        imageRegistry:
          title: Image Registry
          type: string
          description: The container image registry host
          default: quay.io
          ui:help: "On-prem example: quay.apps.cluster.example.com"
        imageOrg:
          title: Image Organization
          type: string
          description: The organization, user or project for container images
        imageName:
          title: Image Name
          type: string
          description: Name for the container image
          ui:autofocus: true
          ui:options:
            rows: 5
        namespace:
          title: Deployment Namespace
          type: string
          default: rhdh-app
          description: Kubernetes namespace for deployment
          ui:autofocus: true
          ui:options:
            rows: 5
        pipelineSecretName:
          title: Pipeline Secrets Name
          type: string
          default: pipeline-secrets
          description: |
            Name of a Kubernetes Secret containing CI/CD pipeline credentials:
            • GIT_TOKEN - GitHub/GitLab PAT for GitOps repository operations
            • GITLAB_TOKEN - GitLab PAT (if using GitLab)
            • WEBHOOK_SECRET - Pipelines as Code webhook secret
            • QUAY_DOCKERCONFIGJSON - Image registry credentials
            Note: Cosign public key is auto-fetched from openshift-pipelines namespace.
            See TechDocs "Pipeline Secrets Configuration" for example YAML.
          ui:help: |
            This secret is used by the initialize-namespace Job to set up Tekton pipelines.
            If not provided, the Job will skip pipeline setup.
        deployArgoCDApplicationOnRemoteCluster:
          title: Deploy on Remote Cluster?
          type: boolean
          default: false
          ui:help: "Requires remote cluster pre-configured in RHDH"
      dependencies:
        deployArgoCDApplicationOnRemoteCluster:
          oneOf:
            - required:
                - remoteClusterAPIUrl
                - remoteClusterDeploymentNamespace
              properties:
                deployArgoCDApplicationOnRemoteCluster:
                  const: true
                remoteClusterAPIUrl:
                  title: Remote Cluster API URL
                  type: string
                  ui:help: "Kube API URL of remote cluster"
                remoteClusterDeploymentNamespace:
                  title: Remote Cluster Namespace
                  type: string
                  ui:help: "Namespace on remote cluster for deployment"
            - properties:
                deployArgoCDApplicationOnRemoteCluster:
                  const: false

  # ==================== Template Steps ====================
  steps:
    # -------------------- SOURCE REPOSITORY --------------------
    # Get the application source code
    - id: fetch-base
      name: Fetch Base
      action: fetch:template
      input:
        url: ../
        targetPath: source
        copyWithoutTemplating:
          - "**/*.py"
          - "**/*.yaml"
          - "**/*.yml"
          - "**/*.json"
          - "**/*.toml"
          - "**/*.lock"
          - "**/*.md"
          - "**/Containerfile"
          - "**/Makefile"
          - "**/.gitignore"

    # Renders all of the template variables into the techdocs
    - id: fetch-skeleton-docs
      name: Fetch Skeleton Techdocs
      action: fetch:template
      input:
        url: ../skeleton/techdoc
        targetPath: source
        values:
          name: ${{ parameters.name }}
          namespace: ${{ parameters.namespace }}
          repoURL: https://${{ parameters.githubServer if parameters.hostType === 'GitHub' else parameters.gitlabServer }}/${{ parameters.repoOwner }}/${{ parameters.repoName }}-gitops
          srcRepoURL: https://${{ parameters.githubServer if parameters.hostType === 'GitHub' else parameters.gitlabServer }}/${{ parameters.repoOwner }}/${{ parameters.repoName }}
          appContainer: quay.io/redhat-ai-dev/agentic-sample:latest
          appPort: 8501
          inferenceModel: ${{ parameters.inferenceModel }}
          guardrailModel: ${{ parameters.guardrailModel }}
          mcpToolModel: ${{ parameters.mcpToolModel }}

    # Renders all the template variables into the files (catalog-info.yaml, .tekton/)
    - id: fetch-skeleton
      name: Fetch Skeleton
      action: fetch:template
      input:
        url: ../skeleton/source-repo
        targetPath: source
        values:
          name: ${{ parameters.name }}
          namespace: ${{ parameters.namespace }}
          description: Llama Stack Agentic AI Workflow Application
          dockerfile: Containerfile
          buildContext: .
          gitopsSecretName: ${{ 'gitops-auth-secret' if parameters.hostType === 'GitHub' else 'gitlab-auth-secret' }}
          image: '${{ parameters.imageRegistry }}/${{ parameters.imageOrg }}/${{ parameters.imageName }}'
          tags: '["ai", "llama-stack", "langgraph", "mcp", "rag", "agents"]'
          owner: ${{ parameters.owner }}
          repoSlug: '${{ parameters.imageOrg }}/${{ parameters.imageName }}'
          defaultBranch: ${{ parameters.branch }}

    # Fetch GitHub Action for automerge (if GitHub)
    - id: fetch-github-action
      name: Fetch GitHub Action
      action: fetch:plain
      if: ${{ parameters.hostType === 'GitHub' }}
      input:
        targetPath: source
        url: ../skeleton/github-action

    # Publish source repository to GitHub
    - id: publish-github
      name: Publish Repository to GitHub
      action: publish:github
      if: ${{ parameters.hostType === 'GitHub' }}
      input:
        sourcePath: source
        description: Llama Stack Agentic AI Workflow - ${{ parameters.name }}
        repoUrl: ${{ parameters.githubServer }}?owner=${{ parameters.repoOwner }}&repo=${{ parameters.repoName }}
        defaultBranch: ${{ parameters.branch }}
        protectDefaultBranch: true
        allowAutoMerge: true
        deleteBranchOnMerge: true
        requiredStatusCheckContexts: []
        repoVisibility: "public"
        requiredApprovingReviewCount: 0

    # Publish source repository to GitLab
    - id: publish-gitlab
      name: Publish Repository to GitLab
      action: publish:gitlab
      if: ${{ parameters.hostType === 'GitLab' }}
      input:
        sourcePath: source
        description: Llama Stack Agentic AI Workflow - ${{ parameters.name }}
        repoUrl: ${{ parameters.gitlabServer }}?owner=${{ parameters.repoOwner }}&repo=${{ parameters.repoName }}
        defaultBranch: ${{ parameters.branch }}
        protectDefaultBranch: false
        repoVisibility: "public"

    # -------------------- GITOPS REPOSITORY --------------------
    # Fetch GitOps skeleton (includes app-of-apps, catalog-info, components/http/base and overlays)
    - id: fetch-gitops-skeleton
      name: Fetch Gitops Skeleton
      action: fetch:template
      input:
        url: ../skeleton/gitops-template
        targetPath: gitops
        values:
          name: ${{ parameters.name }}
          appName: ${{ parameters.name }}-gitops
          description: GitOps manifest for Llama Stack Agentic - ${{ parameters.name }}
          namespace: ${{ parameters.remoteClusterDeploymentNamespace if parameters.deployArgoCDApplicationOnRemoteCluster else parameters.namespace }}
          rhdhNamespace: ai-rhdh
          repoURL: https://${{ parameters.githubServer if parameters.hostType === 'GitHub' else parameters.gitlabServer }}/${{ parameters.repoOwner }}/${{ parameters.repoName }}-gitops
          srcRepoURL: https://${{ parameters.githubServer if parameters.hostType === 'GitHub' else parameters.gitlabServer }}/${{ parameters.repoOwner }}/${{ parameters.repoName }}
          argoComponentOverlays: './components/${{ parameters.name }}/overlays'
          owner: ${{ parameters.owner }}
          argoNS: ${{ parameters.argoNS }}
          argoProject: ${{ parameters.argoProject }}
          secretRef: ${{ parameters.hostType === 'GitLab' }}
          gitSecret: gitlab-auth-secret
          gitSecretKey: password
          webhookSecret: pipelines-secret
          webhookSecretKey: webhook.secret
          defaultBranch: main
          # Application container image
          appContainer: quay.io/redhat-ai-dev/agentic-sample:latest
          llamaStackContainer: quay.io/redhat-ai-dev/agentic-llama-stack:latest
          appPort: 8501
          # Llama Stack configuration
          vllmUrl: ${{ parameters.vllmUrl }}
          safetyModel: ${{ parameters.safetyModel }}
          llamaStackSecretName: ${{ parameters.llamaStackSecretName }}
          # Application configuration
          inferenceModel: ${{ parameters.inferenceModel }}
          mcpToolModel: ${{ parameters.mcpToolModel }}
          githubRepoUrl: ${{ parameters.githubRepoUrl }}
          appSecretName: ${{ parameters.appSecretName }}
          # Provider flags (vLLM and OpenAI always enabled for this template)
          vllmEnabled: true
          openaiEnabled: true
          # Pipeline/Deployment configuration
          pipelineSecretName: ${{ parameters.pipelineSecretName }}
          # Remote cluster configuration
          deployOnRemoteCluster: ${{ parameters.deployArgoCDApplicationOnRemoteCluster }}
          remoteClusterAPIUri: ${{ parameters.remoteClusterAPIUrl }}
          remoteClusterDeploymentNamespace: ${{ parameters.remoteClusterDeploymentNamespace }}
          # Image configuration
          imageRegistry: ${{ parameters.imageRegistry }}
          imageOrg: ${{ parameters.imageOrg }}
          imageName: ${{ parameters.imageName }}
          # App support
          supportApp: true

    # Rename component directory from http to the app name
    - action: fs:rename
      id: renameComponentDir
      name: Rename Component Directory
      input:
        files:
          - from: gitops/components/http
            to: gitops/components/${{ parameters.name }}
            overwrite: true

    # Publish GitOps repository to GitHub
    - id: publish-github-gitops
      name: Publish GitOps Repository to GitHub
      action: publish:github
      if: ${{ parameters.hostType === 'GitHub' }}
      input:
        sourcePath: gitops
        description: GitOps repository for Llama Stack Agentic - ${{ parameters.name }}
        repoUrl: ${{ parameters.githubServer }}?owner=${{ parameters.repoOwner }}&repo=${{ parameters.repoName }}-gitops
        defaultBranch: "main"
        protectDefaultBranch: false
        repoVisibility: "public"

    # Publish GitOps repository to GitLab
    - id: publish-gitlab-gitops
      name: Publish GitOps Repository to GitLab
      action: publish:gitlab
      if: ${{ parameters.hostType === 'GitLab' }}
      input:
        sourcePath: gitops
        description: GitOps repository for Llama Stack Agentic - ${{ parameters.name }}
        repoUrl: ${{ parameters.gitlabServer }}?owner=${{ parameters.repoOwner }}&repo=${{ parameters.repoName }}-gitops
        defaultBranch: "main"
        protectDefaultBranch: false
        repoVisibility: "public"

    # -------------------- REGISTRATION & ARGOCD --------------------
    # Wait for repository availability
    - id: wait-for-github-repository
      name: Waiting for Repository Availability
      action: 'debug:wait'
      input:
        seconds: 3

    # Register source repository
    - id: register
      name: Register
      action: catalog:register
      input:
        repoContentsUrl: ${{ steps['publish-github'].output.repoContentsUrl if steps['publish-github'].output else steps['publish-gitlab'].output.repoContentsUrl }}
        catalogInfoPath: '/catalog-info.yaml'

    # Register GitOps repository
    - id: register-gitops
      name: Register Gitops
      action: catalog:register
      input:
        repoContentsUrl: ${{ steps['publish-github-gitops'].output.repoContentsUrl if steps['publish-github-gitops'].output else steps['publish-gitlab-gitops'].output.repoContentsUrl }}
        catalogInfoPath: '/catalog-info.yaml'

    # Create ArgoCD resources
    - id: create-argocd-resources
      name: Create ArgoCD Resources
      action: argocd:create-resources
      input:
        appName: ${{ parameters.name }}-app-of-apps
        argoInstance: ${{ parameters.argoInstance }}
        namespace: ${{ parameters.argoNS }}
        labelValue: ${{ parameters.argoAppLabel if parameters.includeArgoLabel else '' }}
        repoUrl: https://${{ parameters.githubServer if parameters.hostType === 'GitHub' else parameters.gitlabServer }}/${{ parameters.repoOwner }}/${{ parameters.repoName }}-gitops.git
        path: './app-of-apps'

    # PR to trigger pipeline build (GitHub only)
    - id: trigger-build-pr
      name: PR to Trigger Pipeline Build
      action: publish:github:pull-request
      if: ${{ parameters.hostType === 'GitHub' }}
      input:
        repoUrl: ${{ parameters.githubServer }}?owner=${{ parameters.repoOwner }}&repo=${{ parameters.repoName }}
        branchName: trigger-pipeline
        commitMessage: trigger pipeline build
        description: "PR to trigger pipeline build"
        title: trigger pipeline build
        sourcePath: source
        targetBranchName: ${{ parameters.branch }}

    # Dispatch GitHub workflow to automerge
    - id: trigger_gh_workflow
      name: Trigger GitHub workflow
      action: github:actions:dispatch
      if: ${{ parameters.hostType === 'GitHub' }}
      input:
        repoUrl: ${{ parameters.githubServer }}?owner=${{ parameters.repoOwner }}&repo=${{ parameters.repoName }}
        branchOrTagName: ${{ parameters.branch }}
        workflowId: automerge.yml
        workflowInputs: {pr_url: "${{ steps['trigger-build-pr'].output.remoteUrl }}"}

  # ==================== Output Links ====================
  output:
    links:
      - title: Source Repository
        url: ${{ steps['publish-github'].output.remoteUrl if steps['publish-github'].output else steps['publish-gitlab'].output.remoteUrl }}
      - title: GitOps Repository
        url: ${{ steps['publish-github-gitops'].output.remoteUrl if steps['publish-github-gitops'].output else steps['publish-gitlab-gitops'].output.remoteUrl }}
      - title: Open Component in Catalog
        icon: catalog
        entityRef: ${{ steps['register'].output.entityRef }}
      - title: Open GitOps Resource in Catalog
        icon: catalog
        entityRef: ${{ steps['register-gitops'].output.entityRef }}
